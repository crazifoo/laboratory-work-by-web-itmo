## Вопросы

[1. Платформа Java EE. Спецификации и их реализации.](#платформа-java-ee-спецификации-и-их-реализации)

[2. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.](#принципы-ioc-cdi-и-location-transpanency-компоненты-и-контейнеры)

[3. Управление жизненным циклом компонентов. Дескрипторы развёртывания.](#управление-жизненным-циклом-компонентов-дескрипторы-развёртывания)

[4. Java EE API. Виды компонентов. Профили платформы Java EE.](#java-ee-api-виды-компонентов-профили-платформы-java-ee)

[5. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.](#компоненты-ejb-stateless-&-stateful-session-beans-ejb-lite-и-ejb-full)

[6. Работа с электронной почтой в Java EE. JavaMail API.](#работа-с-электронной-почтой-в-java-ee-javamail-api)

[7. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.](#jms-реализация-очередей-сообщений-способы-доставки-сообщений-до-клиента-message-driven-beans)

[8. Понятие транзакции. Управление транзакциями в Java EE. JTA.](#понятие-транзакции-управление-транзакциями-в-java-ee-jta)

[9. Веб-сервисы. Технологии JAX-RS и JAX-WS.](#веб-сервисы-технологии-jax-rs-и-jax-ws)

[10. Платформа Spring. Сходства и отличия с Java EE.](#платформа-spring-сходства-и-отличия-с-java-ee)

[11. Модули Spring. Архитектура Spring Runtime. Spring Security и Spring Data.](#модули-spring-архитектура-spring-runtime-spring-security-и-spring-data)

[12. Реализация IoC и CDI в Spring. Сходства и отличия с Java EE.](#реализация-ioc-и-cdi-в-spring-сходства-и-отличия-с-java-ee)

[13. Реализация REST API в Java EE и Spring.](#реализация-rest-api-в-java-ee-и-spring)

[14. React JS. Архитектура и основные принципы разработки приложений.](#react-js-архитектура-и-основные-принципы-разработки-приложений)

[15. Компоненты React. State & props. "Умные" и "глупые" компоненты.](#компоненты-react-state-&-props-"умные"-и-"глупые"-компоненты)

[16. Разметка страниц в React-приложениях. JSX.](#разметка-страниц-в-react-приложениях-jsx)

[17. Навигация в React-приложениях. ReactRouter.](#навигация-в-react-приложениях-reactrouter)

[18. Управление состоянием интерфейса. Redux.](#управление-состоянием-интерфейса-redux)

[19. Angular: архитектура и основные принципы разработки приложений.](#angular-архитектура-и-основные-принципы-разработки-приложений)

[20. Angular: модули, компоненты, сервисы и DI](#angular-модули-компоненты-сервисы-и-di)

[21. Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.](#angular-шаблоны-страниц-жизненный-цикл-компонентов-подключение-css)

[22. Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.](#angular-клиент-серверное-взаимодействие-создание-отправка-и-валидация-данных-форм)


### Платформа Java EE. Спецификации и их реализации.

В основе технологии Java EE лежит четыре основных документа:

- Java EE Platform Specification (спецификация платформы Java EE);
- Java EE Reference Implementation (образцовые реализации платформы Java EE);
- Java EE Blueprints (модель приложений Java EE);
- Java Compatibility Test Suite (набор тестов на совместимость платформы Java EE).

***<ins>Спецификация Java EE Platform</ins>*** определяет компонентную структуру Java EE приложения и содержит минимальный набор свойств, которыми должен обладать сервер приложений `Application server`, поддерживающий эту платформу.

***Сервер приложений*** – это сервер, умеющий исполнять прикладные программы, специальным образом установленные на нем. Существует достаточно много различных Java EE-серверов: `Sun GlassFish Enterprise Server`, `Oracle Application Sever`, `JBOSS` и т. д. Важным является, то что, если любые два сервера приложений соответствуют спецификации Java EE Platform, то любое Java EE-приложение которое может быть исполнено на одном сервере без перекомпиляции может быть исполнено и на нем. Составной частью любого сервера приложений (AS) является **web-сервер** (его часто называют **web-контейнером**). В некоторых случаях это может быть отдельный продукт, который встраивается в сервер, в других случаях web-сервер может являться неотделимой составной частью сервера приложений или вообще могут использоваться, как несколько различных web-серверов, так и собственный встроенный.

***<ins>Образцовые реализации платформы Java EE</ins>*** – это практические указания по разработке программных продуктов соответствующих спецификации этой платформы, а также сами действующие программные продукты, образцовые реализации платформы Java EE могут быть использованы в качестве образца (сервер приложений Sun GlassFish Enterprise Server).

***<ins>Модель приложений Java EE</ins>*** предназначена прикладным программистам, разрабатывающим приложения для этой платформы.

***<ins>Набор тестов на совместимость платформы Java EE</ins>***, предназначен, в основном, для разработчиков серверов приложений, реализующих платформу Java EE. С помощью, предложенных здесь тестов, можно проверить, разработанный продукт на соответствие спецификациям (иногда говорят стандартам) платформы Java EE.

Основными **web-технологиями** являются технологии JavaServlet (технология сервлетов) и Java ServerPages.


### Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.

**Inversion of Control (инверсия управления):** объекты создает ***не программист*** (используя `new`), а контейнер `IoC`. Применяется далеко не ко всем объектам в приложении, а только к управляемым (в Spring это классы с аннотациями `@Component`, `@Service` и т.д., в EJB — бобы `@Stateless`, `@Stateful`, `@MessageDriven`).

Контейнер не только создает объекты, но полностью управляет их жизненным циклом, вызывая на определенных этапах callback методы.

**Dependency Injection (внедрение зависимостей)** — это одна из реализаций этого принципа (помимо этого есть еще [Factory Method](http://en.wikipedia.org/wiki/Factory_pattern), [Service Locator](http://en.wikipedia.org/wiki/Service_locator_pattern)).

Вместо построения зависимостей в компоненте, где они нужны:

```java
public class Something {
 private Dependency dependency = new Dependency()
}
```

Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:

```java
public class Something {
  private Dependency dependency;

  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
} 
```

Чтобы нам не пришлость вручную собирать все зависимости для создания компонентов, контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:

```java
public class SomethingDI {
  @EJB 
  private EjbDependency ejbDependency; // EJB
  @Autowired 
  private Dependency dependency; // Spring
}
```

**Внедрение зависимостей в CDI**

- [Внедрение зависимостей в CDI. Часть 1](https://habr.com/ru/company/at_consulting/blog/301636/)
- [Внедрение зависимостей в CDI. Часть 2](https://habr.com/ru/company/at_consulting/blog/301768/)
- [Внедрение зависимостей в CDI. Часть 3](https://habr.com/ru/company/at_consulting/blog/302010/)

**Компоненты**

В среде времени выполнения Java EE выделяют четыре типа компонентов, которые должна поддерживать реализация.

- **Апплеты** представляют собой приложения из графического пользовательского интерфейса `GUI`, выполняемые в браузере. Они задействуют насыщенный интерфейс `Swing API` для производства мощных пользовательских интерфейсов.<sup>[\[source\]][containers-and-components]</sup>

- **Приложениями** называются программы, выполняемые на клиентской стороне. Как правило, они относятся к графическому пользовательскому интерфейсу `GUI` и применяются для пакетной обработки. Приложения имеют доступ ко всем средствам среднего звена.<sup>[\[source\]][containers-and-components]</sup>

- **Веб-приложения** (состоят из сервлетов и их фильтров, слушателей веб-событий, страниц JSP и JSF) выполняются в веб-контейнере и отвечают на запросы `HTTP` от ***веб-клиентов***. Сервлеты также поддерживают конечные точки веб-служб `SOAP` и `RESTful`. Веб-приложения также могут содержать компоненты `EJBLite`.<sup>[\[source\]][containers-and-components]</sup>

- **Корпоративные приложения** (созданные с помощью технологии Enterprise Java Beans, службы сообщений Java Message Service, интерфейса Java API для транзакций, асинхронных вызовов, службы времени, протоколов `RMI-IIOP`) выполняются в контейнере `EJB`. Управляемые контейнером компоненты EJB служат для обработки транзакционной бизнес логики. Доступ к ним может быть как локальным, так и удаленным по протоколу `RMI` (или `HTTP` для веб-служб `SOAP` и `RESTful`).<sup>[\[source\]][containers-and-components]</sup>

**Контейнеры**

Инфраструктура Java EE подразделяется на логические домены, называемые *контейнерами*. Каждый из контейнеров играет свою специфическую роль, поддерживает набор интерфейсов API и предлагает *компонентам* сервисы (безопасность, доступ к базе данных, обработку транзакций, присваивание имен каталогам, внедрение ресурсов). Контейнеры скрывают техническую сложность и повышают мобильность. При разработке приложений каждого типа необходимо учитывать возможности и ограничения каждого контейнера, чтобы знать, использовать один
или несколько. Например, для разработки веб-приложения необходимо сначала разработать уровень фреймворка `JSF` и уровень `EJB Lite`, a затем развернуть их
в веб-контейнер. Но если вы хотите, чтобы веб-приложение удаленно вызывало бизнес-уровень, а также использовало передачу сообщений и асинхронные вызовы,
вам потребуется как `веб-`, так и `EJB-контейнер`. Java EE использует четыре различных контейнера.

- **Контейнеры апплетов** выполняются большинством браузеров. При разработке апплетов можно сконцентрироваться на визуальной стороне приложения, в то время как контейнер обеспечивает безопасную среду. Контейнер апплета использует модель безопасности изолированной программной среды («песочницы»), где коду, выполняемому в «песочнице», не разрешается «играть» за ее пределами. Это означает, что контейнер препятствует любому коду, загруженному на ваш локальный компьютер, получать доступ к локальным ресурсам системы (процессам либо файлам).<sup>[\[source\]][containers-and-components]</sup>

- **Контейнер клиентского приложения** `(ACC)` включает набор Java-классов, библиотек и других файлов, необходимых для реализации в приложениях Java SE таких возможностей, как внедрение, управление безопасностью и служба именования (в частности, Swing, пакетная обработка либо просто класс сметодом `main()`). Контейнер `ACC` обращается к EJB-контейнеру, используя протокол `RMI-IIOP`, а к веб-контейнеру — по протоколу `HTTP` (например, для `веб-служб`).<sup>[\[source\]][containers-and-components]</sup>

- **Веб-контейнер** предоставляет базовые службы для управления и исполнения веб-компонентов (сервлетов, компонентов EJB Lite, страниц JSP, фильтров, слушателей, страниц JSF и веб-служб). Он отвечает за создание экземпляров, инициализацию и вызов сервлетов, а также поддержку протоколов `HTTP` и `HTTPS`. Этот контейнер используется для подачи *веб-страниц* к *клиент-браузерам*.<sup>[\[source\]][containers-and-components]</sup>

- **EJB-контейнер** отвечает за управление и исполнение компонентов модели `EJB` (компонент-сеансы EJB и компоненты, управляемые сообщениями), содержащих уровень бизнес-логики вашего приложения на ***Java EE***. Он создает новые сущности компонентов `EJB`, управляет их жизненным циклом и обеспечивает реализацию таких сервисов, как транзакция, безопасность, параллельный доступ, распределение, служба именования либо возможность асинхронного вызова.<sup>[\[source\]][containers-and-components]</sup>

- [More about conponents and containers...][more-about-components-and-containers]

[containers-and-components]: https://storage.piter.com/upload/contents/978549600942/978549600942_p.pdf
[more-about-components-and-containers]: https://gist.github.com/vchernogorov/0911283eac106117991da153a344b752#file-java-ee-containers-md


### Управление жизненным циклом компонентов. Дескрипторы развёртывания.

**Web-контейнер** реализует такие службы, как управление жизненным циклом компонентов и набором компонентов как ресурсом, распараллеливание независимых работ, выполнение удаленных обращений к компонентам, поддержка защищенности с помощью проверки прав компонентов и пользователей на выполнение различных операций.<sup>[\[more\]][life-cycle]</sup>

[life-cycle]: https://intuit.ru/studies/courses/64/64/lecture/1890?page=2

**Дескриптор развёртывания** — конфигурационный файл артефакта, который будет развёрнут в контейнере сервлетов. В спецификации Java Platform, Enterprise Edition дескриптор развёртывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развёрнуто.

Этот конфигурационный файл указывает параметры развёртывания для модуля или приложения с определёнными настройками, параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развёртывания используется язык `XML`.


### Java EE API. Виды компонентов. Профили платформы Java EE.

**Enterprise JavaBeans** имеет спецификацию написания и поддержки серверных компонентов, содержащих бизнес-логику. Данная технология применяется, как правило, в том случае, если бизнес-логика требует один или несколько следующих сервисов :

- сервис распределённых транзакций;
- сервис сохранности данных (**persistence**);
- сервис управления данными;
- сервис событий;
- сервис именования и каталогов `(JNDI)`;
- сервис безопасности и ограничения доступа к данным.

Технологию EJB можно рассматривать в двух аспектах: ***фреймворк*** и ***компонент***. С точки зрения фреймворка **EJB** - это технология, предоставляющая для серверной части WEB-приложения множество готовых решений (управление транзакциями, безопасность, хранение информации и т.п.). С точки зрения компонента **EJB** - это надстройка над `POJO-классом`, описываемая с помощью аннотаций.

**Основные типы компонентов EJB:** В языке **EJB** под компонентом подразумевается зерно (Bean), а под **Enterprise** подразумевают «корпоративный». EJB делит компоненты (зерна) на несколько типов, исходя из их предназначения :

- **сессионные (Session Beans)**, которые могут быть
  - `stateful` - с сохранением текущего состояния;
  - `stateless` - без сохранения состояния;
  - `singleton` - один объект для всех приложений (начиная с EJB версии 3.1).
- **управляемые сообщениями (Message Driven Beans)** — их логика является реакцией на события в системе;
- **объектные (Entity Bean)** — определены в спецификации JPA (Java Persistence API) entities и используются для хранения данных.


### Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.

В языке **EJB** под компонентом подразумевается зерно (Bean), а под **Enterprise** подразумевают «корпоративный». EJB делит компоненты (зерна) на несколько типов, исходя из их предназначения :

- **сессионные (Session Beans)**, которые могут быть:
  - **stateful** - с сохранением текущего состояния;
  - **stateless** - без сохранения состояния;
  - **singleton** - один объект для всех приложений (начиная с EJB версии 3.1).
- **управляемые сообщениями (Message Driven Beans)** — их логика является реакцией на события в системе;
- **объектные (Entity Bean)** — определены в спецификации JPA (Java Persistence API) entities и используются для хранения данных.

**Сессионный компонент Session Beans**, иначе называемый сеансовый, вызывается клиентом (браузером) для выполнения вполне определенных операций, таких как, к примеру, проверка кредитной истории клиента. Слово ***«сессионный»*** предполагает, что экземпляр компонента доступен только на время выполнения определенной задачи сервером, и безвозвратно уничтожается в случае аварии или остановки сервера. Для доступа к серверной части приложения, клиент вызывает методы сессионного компонента, выполняющего определенные бизнес-задачи внутри сервера.

**Сеансовый компонент с сохранением состояния EJB stateful** автоматически сохраняет свое состояние между обращениями к нему от одного и того же клиента, и завершает свое существование либо по таймауту, либо по явному запросу клиента. Типичным примером компонента с сохранением состояния является корзина с покупками в интернет-магазине.

**Сеансовые компоненты без сохранения состояния EJB stateless** не хранят никакой информации о своем состоянии и являются прикладными службами, которые выполняют все необходимые действия в рамках запроса. **EJB stateless** можно использовать для реализации таких операций, как перевод средств на кредитную карту или проверку кредитной истории клиента. На основе `stateless-бинов` проектируются `WEB-сервисы`.

**Компоненты-одиночки EJB singleton** используются совместно всеми клиентами, имеющими к ним доступ, и продолжают свое существование на протяжении всего времени работы приложения. Информацию о своем состоянии **EJB singleton** сохраняет. Компонент-одиночку можно использовать, к примеру, в интернет-магазине для реализации скидки, поскольку правила предоставления скидки фиксированы и распространяются на всех клиентов.

<ins>Сеансовые компоненты</ins> могут вызываться локально или удаленно, посредством Java RMI. Компоненты-одиночки и компоненты без сохранения состояния могут также экспортироваться в виде веб-служб `SOAP` (Simple Object Access Protocol) или `REST` (Representational State Transfer).

**Компоненты управляемые сообщениями MDB (Message-Driven Bean)** подобно сеансовым компонентам реализуют некоторую прикладную логику и имеют одно важное отличие: клиенты никогда ***не вызывают методы MDB напрямую***. Вместо этого компоненты MDB вызываются для обработки отправленных на сервер сообщений, что позволяет организовать асинхронный обмен сообщениями между частями системы. Типичными примерами подобных серверов сообщений могут служить IBM WebSphere MQ, Oracle Advanced Queueing и TIBCO. Компоненты MDB, как правило, применяются для повышения надежности интеграции систем и асинхронной обработки данных. Примером MDB сообщения может быть запрос на доставку товарных запасов от автоматизированной системы розничной торговли к системе управления поставками.


### JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.

Работа с сообщениями подразумевает ***взаимодействие между компонентами системы посредством передачи сообщений***. `JMS` позволяет реализовать это взаимодействие в java приложении, а `MDB` бины позволяют ***асинхронно обрабатывать*** получаемые сообщения на сервере приложений без дополнительных усилий по асинхронной обработке.

Для работы с сообщениями используется вспомогательное программное обеспечение, обычно входящее в поставку сервера приложений. Компоненты системы могут *посылать* сообщения (producer) и *получать* их (consumer). Сообщение отправляет producer на пункт назначения (destination), являющимся на сервере **queue** или **topic**, после чего consumer может забрать оттуда сообщение в зависимости от того, какой тип имеет **destination**, разделяют <ins>две модели</ins> работы с сообщениями:

#### Первая модель - Point-to-Point

В случае если на сервере destination имеет тип queue, то сообщение, которое отправил producer, получает **<ins>единственный consumer</ins>**. Если на эту очередь сообщений подписано несколько получателей, то сообщение получит только один из них</ins>.

#### Вторая модель - Publish-subscribe

В случае если на сервере destination имеет тип topic, то одно сообщение может быть прочитано **<ins>неограниченным количеством consumer</ins>**, подписанных на этот на этот destination.

#### Структура JMS сообщения

Сообщение состоит из заголовка, поля свойств и тела:

- ***Заголовок*** хранит мета информацию сообщения, заполняемую автоматически.
- ***Поле свойств*** схоже с заголовком, но оно заполняется программно, и позже получатель сможет прочитать эту информацию.
- ***Тело*** содержит полезную нагрузку сообщения. Тип нагрузки определяется при создании сообщения. Конкретные типы унаследованы от интерфейса `javax.jms.Message`

#### Создание очереди на сервере

Для начала создадим `Connection Factory`. Возможны несколько типов в зависимости от того, какой тип очереди сообщений будет использоваться.

Затем создаем `destination` с указание **типа**.

#### Создание отправителя сообщений

В данном случае producer будет находиться на сервере приложений. В случае если вам необходимо отправлять сообщения из отдельного клиента, то необходимо будет стандартным образом получить доступ к объектам по их JNDI имени из контекста.

```java
//получаем ресурсы сервера для отправки сообщений
    @Resource(name="jms/TutorialPool")
    private ConnectionFactory connectionFactory;
    
    @Resource(name="jms/TutorialTopic")
    private Destination destination;

    public String getEnterString() {
        return enterString;
    }

    public void sendString(String enterString) {
        try {
            //создаем подключение
            Connection connection = connectionFactory.createConnection();
            Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
            MessageProducer producer = session.createProducer(destination);
            TextMessage message = session.createTextMessage();
            //добавим в JMS сообщение собственное свойство в поле сообщения со свойствами
            message.setStringProperty("clientType", "web clien");
            //добавляем payload в сообщение
            message.setText(enterString);
            //отправляем сообщение
            producer.send(message);
            System.out.println("message sent");
	    //закрываем соединения
            session.close();
            connection.close();

        } catch (JMSException ex) {
            System.err.println("Sending message error");
            ex.printStackTrace();
        } 
  }
```

#### Message-Driven Bean

Для обработки приходящих сообщений на сервере мы будем использовать MDB.

Сообщения можно было бы получать и обрабатывать и с помошью pojo, выступающего как consumer. Но использование MDB позволит параллельно обрабатывать сообщения, не заботясь о сложности асинхронной обработки и дополнительного кода для подписки на очередь сообщений.
Асинхронная обработка реализуется через пул объектов, из которых на обработку сообщения сервер выделят объекты при необходимости.

Для реализации `MBD` достаточно унаследовать бин от интерфейса `javax.jms.MessageListener`, реализуя метод `onMessage()`, и аннотировать соответствующим образом класс.

Сделаем пример MDB, который выводит в консоль сервера информацию о поступившем сообщении.

```java
@MessageDriven(
        //имя topic, на который подписан бин
        mappedName="jms/TutorialTopic",
        name = "ExampleMDB")
public class MDBExample implements MessageListener{
    
    //метод, вызываемый при получении нового сообщения
    @Override
    public void onMessage(Message msg) {
        try {
            TextMessage message = (TextMessage)msg;
            //считываем свойство из соответствующего поля, заданное вручную в consumer
            System.out.println("FROM MDB - client type IS " + message.getStringProperty("clientType"));
            //считываем  само сообщение
            System.out.println("FROM MDB - payload  IS" + message.getText());
        } catch (JMSException ex) {
            ex.printStackTrace();
        }
    }
    
}
```

В onMessage метод добавляется необходимая бизнес логика, в зависимости от типа сообщения, его содержания и тд.

При необходимости, для ручной обработки сообщений можно самостоятельно создать обработчика.
Например так:

```java
@Resource(name="jms/TutorialPool")
private ConnectionFactory connectionFactory;

@Resource(name="jms/TutorialTopic")
private Destination destination;

void onMessage(){
    try {
        Connection connection = connectionFactory.createConnection();
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        MessageConsumer consumer = session.createConsumer(destination);
        connection.start();
        while(true){
            Message msg = consumer.receive();
            //обработка сообщения
        }
      //закрыть connection  
    } catch (JMSException ex) {
        ex.printStackTrace();
    }
}
```
[Смотрите новые фичи JMS](https://habr.com/ru/post/184460/)


#### Понятие транзакции. Управление транзакциями в Java EE. JTA

**Транзакция** — группа последовательных операций, представляет собой логическую единицу работы с данными.

Транзакции должны удовлетворять свойствам ACID: (Все или ничего =))

- **Атомарность**. Транзакция либо выполняется полностью либо не выполняется вовсе.
- **Согласованность**. При завершении транзакции не должны быть нарушены ограничения накладываемые на данные (например constraints в БД). Согласованность подразумевает, что система будет переведена из одного корректного состояния в другое корректное.
- **Изолированность**Параллельно выполняемые транзакции не должны влиять друг на друга, например менять данные которые использует другая транзакция. Результат выполнения параллельных транзакций должен быть таким, как если бы транзакции выполнялись последовательно.
- **Устойчивость**. После фиксации изменения не должны быть утеряны.

**Журнал транзакций**

***Журнал*** хранит изменения выполненные транзакциями, обеспечивает атомарность и устойчивость данных в случае сбоя системы.

Журнал содержит значения, которые данные имели до и после их изменения транзакцией. *Write-ahead* log strategy обязывает добавлять в журнал запись о предыдущих значениях до начала, а о конечных после завершения транзакции. В случае внезапной остановки системы БД читает лог в обратном порядке и отменяет изменения сделанные транзакциями. Встретив прерванную транзакцию БД выполняет ее и вносит изменения о ней в журнал. Находясь в состоянии на момент сбоя, БД читает лог в прямом порядке и возвращает изменения сделанные транзакциями. Таким образом сохраняется устойчивость транзакций которые уже были зафиксированы и атомарность прерванной транзакции.

Простое повторное выполнение ошибочных транзакций недостаточно для восстановления.

**Уровни изоляции**

1. **Чтение фиксированных данных (Read Committed)**

Проблема грязного чтения (Dirty Read) заключается в том, что транзакция может прочесть промежуточный результат работы другой транзакции.

*Пример. Начальное значение баланса 0$. Т1 добавляет к балансу 50$. Т2 считывает значение баланса (50$). Т1 отменяет изменения и завершается. T2 продолжает выполнение располагая неверными данными о балансе.*

Решением является чтение фиксированных данных (Read Committed) запрещающее читать данные, измененные транзакцией. Если транзакция A изменила некоторый набор данных, то транзакция B при обращении за этими данными вынуждена ожидать завершения транзакции A.

2. **Повторяемое чтение (Repeatable Read)**

Проблема потерянных изменений (Lost Updates). Т1 сохраняет изменения поверх изменений Т2.

*Пример. Начальное значение баланса 0$ и две транзакции одновременно пополняют баланс. T1 и T2 читают баланс равный 0$. Затем T2 прибавляет 200$ к 0$ и сохраняет результат. T1 прибавляет 100$ к 0$ и сохраняет результат. Итоговый результат 100$ вместо 300$.*

Проблема неповторяемого чтения (Unrepeatable read). Повторное чтение одних и тех же данных возвращает разные значения.

*Пример. Т1 читает значение баланса равное 0$. Затем Т2 добавляет к балансу 50$ и завершается. Т1 повторно читает данные и обнаруживает несоответствие с предыдущим результатом.*

Повторяемое чтение (Repeatable Read) гарантирует что повторное чтение вернет тот же результат. Данные прочитанные одной транзакцией запрещено менять в других до завершения транзакции. Если транзакция A прочла некоторый набор данных, то транзакция B при обращении за этими данными вынуждена ожидать завершения транзакции A.

3. **Упорядоченное чтение (Serializable)**

Проблема фантомного чтения (Phantom Reads). Два запроса выбирающие данные по некоему условию возвращают разные значения.

*Пример. T1 запрашивает количество всех пользователей баланс которых больше 0$ но меньше 100$. T2 вычитает 1$ у пользователя с балансом 101$. T1 повторно выполняет запрос.*

Упорядоченное чтение (Serializable). Транзакции выполняются как полностью последовательные. Запрещается обновлять и добавлять записи, подпадающие под условия запроса. Если транзакция A запросила данные всей таблицы, то таблица целиком замораживается для остальных транзакций до завершения транзакции A.


JTA предоставляет высокоуровневый интерфейс для управления транзакиями (begin, commit, rollback), избавляя от необходимости работы с каждым ресурсом по-своему (интерфейс транзакций в JDBC, например, немного отличается от интерфейса JMS).

Транзация координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.

Транзакции могут быть объявлены:

- **декларативно** — аннотацией @Transactional на отдельном методе или всем классе, при этом rollback происходит при необработанном `RuntimeException`
- **программно** — вызывая begin, rollback, commit у UserTransaction
